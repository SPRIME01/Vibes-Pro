#!/usr/bin/env bash
# {{ project_name }} - Enhanced Token Counter with ML-Powered Optimization
# Generated from VibePro prompt-optimizer template

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
ENHANCED_SCRIPT="${SCRIPT_DIR}/measure_tokens_enhanced.py"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

show_help() {
    cat << EOF
{{ project_name }} - Enhanced Token Counter with ML-Powered Prompt Optimization

USAGE:
    $0 <prompt-file> [OPTIONS]

OPTIONS:
    --analyze                   Perform detailed prompt analysis (default)
    --optimize                  Optimize the prompt for effectiveness
    --goal <goal>              Optimization goal: clarity|conciseness|effectiveness|token_efficiency
    --model <model>            AI model: gpt-4|gpt-4-turbo|gpt-3.5-turbo|claude-3-opus|claude-3-sonnet
    --format <format>          Output format: human|json
    --legacy                   Use legacy word-based estimation only
    --help                     Show this help message

EXAMPLES:
    # Basic analysis with enhanced features
    $0 my_prompt.txt

    # Optimize for clarity
    $0 my_prompt.txt --optimize --goal clarity

    # Get JSON output for integration
    $0 my_prompt.txt --analyze --format json

    # Use legacy mode for simple word count
    $0 my_prompt.txt --legacy

The enhanced mode provides:
‚Ä¢ Accurate token counting using tiktoken
‚Ä¢ ML-powered effectiveness analysis
‚Ä¢ Prompt optimization suggestions
‚Ä¢ Cost estimation
‚Ä¢ Temporal learning from usage patterns
‚Ä¢ Integration with {{ project_name }} AI context system

Generated with VibePro prompt-optimizer template
EOF
}

check_dependencies() {
    # Check if Python enhanced script exists
    if [[ ! -f "${ENHANCED_SCRIPT}" ]]; then
        echo -e "${RED}Error: Enhanced script not found at ${ENHANCED_SCRIPT}${NC}" >&2
        return 1
    fi

    # Check if Python is available
    if ! command -v python3 &> /dev/null; then
        echo -e "${YELLOW}Warning: Python3 not found, falling back to legacy mode${NC}" >&2
        return 1
    fi

    return 0
}

legacy_count() {
    local prompt_file="$1"

    if [[ ! -f "${prompt_file}" ]]; then
        echo -e "${RED}Error: prompt file '${prompt_file}' does not exist.${NC}" >&2
        exit 1
    fi

    local word_count char_count
    word_count=$(wc -w < "${prompt_file}")
    char_count=$(wc -c < "${prompt_file}")

    echo -e "${BLUE}[{{ project_name }}] Legacy Token Analysis for ${prompt_file}:${NC}"
    echo -e "  üìä Approximate word count: ${GREEN}${word_count}${NC}"
    echo -e "  üìä Character count: ${GREEN}${char_count}${NC}"
    echo -e "  ü§ñ Estimated tokens (rough): ${GREEN}$((word_count * 4 / 3))${NC}"
    echo ""
    echo -e "${YELLOW}üí° For accurate token counting and optimization, install Python dependencies${NC}"
    echo -e "${YELLOW}   and use enhanced mode (remove --legacy flag)${NC}"
}

enhanced_count() {
    local prompt_file="$1"
    shift
    local args=("$@")

    # Default to analyze mode if no command specified
    if [[ ! " ${args[*]} " =~ " --optimize " ]]; then
        args=("analyze" "${args[@]}")
    else
        # Replace --optimize with optimize command
        local new_args=()
        local skip_next=false
        for arg in "${args[@]}"; do
            if [[ "${skip_next}" == "true" ]]; then
                skip_next=false
                continue
            fi

            if [[ "${arg}" == "--optimize" ]]; then
                new_args+=("optimize")
            elif [[ "${arg}" == "--goal" ]]; then
                skip_next=true
                new_args+=("${arg}")
            else
                new_args+=("${arg}")
            fi
        done
        args=("${new_args[@]}")
    fi

    # Execute the enhanced Python script
    python3 "${ENHANCED_SCRIPT}" "${prompt_file}" "${args[@]}"
}

main() {
    local prompt_file=""
    local use_legacy=false
    local remaining_args=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --legacy)
                use_legacy=true
                shift
                ;;
            -*)
                remaining_args+=("$1")
                shift
                ;;
            *)
                if [[ -z "${prompt_file}" ]]; then
                    prompt_file="$1"
                else
                    remaining_args+=("$1")
                fi
                shift
                ;;
        esac
    done

    # Validate prompt file argument
    if [[ -z "${prompt_file}" ]]; then
        echo -e "${RED}Error: prompt file argument is required.${NC}" >&2
        echo ""
        show_help
        exit 1
    fi

    # Check if file exists
    if [[ ! -f "${prompt_file}" ]]; then
        echo -e "${RED}Error: prompt file '${prompt_file}' does not exist.${NC}" >&2
        exit 1
    fi

    # Determine which mode to use
    if [[ "${use_legacy}" == "true" ]]; then
        legacy_count "${prompt_file}"
    elif check_dependencies; then
        echo -e "${BLUE}üöÄ {{ project_name }} - Using enhanced ML-powered analysis...${NC}"
        enhanced_count "${prompt_file}" "${remaining_args[@]}"
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Falling back to legacy mode...${NC}"
        legacy_count "${prompt_file}"
    fi
}

# Only run main if script is executed directly (not sourced)
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
